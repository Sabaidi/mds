
import numpy as np 
import pandas as pd
from sklearn import svm
from sklearn.model_selection import GridSearchCV, cross_val_score
from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split


def Dirac_kernel(x,y):
    
    r=0
    if x == y : r = 1

    
    return r 

def Uniform_kernel(x,y):
    
    
    return 1

def Multitask_kernel(x,y):
    
    
    return Dirac_kernel(x,y) + Uniform_kernel(x,y)



def Peptide_kernel(x,y):
   
    r =0
    for l in range(len(x)):
        if x[l] == y[l] : r+=1
    return r

def Supertype_kernel(x,y):
    
    r = Multitask_kernel(x[1],y[1])
    if x[0]==y[0] and x[0] != -1 : r += 1

    return r


sasa = []



def first_kernel(X1,X2):


    gram_matrix = np.zeros((X1.shape[0], X2.shape[0]))
    for i, x1 in enumerate(X1):
        for j, x2 in enumerate(X2):
            x1 = x1.flatten()
            x2 = x2.flatten()
            gram_matrix[i, j] = Peptide_kernel(x1[1:10],x2[1:10]) * Dirac_kernel(x1[0],x2[0])
    sasa.append(gram_matrix)
    
    return gram_matrix


def second_kernel(X1,X2):

    
    gram_matrix = np.zeros((X1.shape[0], X2.shape[0]))
    for i, x1 in enumerate(X1):
        for j, x2 in enumerate(X2):
            x1 = x1.flatten()
            x2 = x2.flatten()
            gram_matrix[i, j] = Peptide_kernel(x1[1:10],x2[1:10]) * Uniform_kernel(x1[0],x2[0])
    sasa.append(gram_matrix)
    
    return gram_matrix


def third_kernel(X1,X2):


    gram_matrix = np.zeros((X1.shape[0], X2.shape[0]))
    for i, x1 in enumerate(X1):
        for j, x2 in enumerate(X2):
            x1 = x1.flatten()
            x2 = x2.flatten()
            gram_matrix[i, j] = Peptide_kernel(x1[1:10],x2[1:10]) * Multitask_kernel(x1[0],x2[0])
    sasa.append(gram_matrix)
    
    return gram_matrix


def fourth_kernel(X1,X2):


    gram_matrix = np.zeros((X1.shape[0], X2.shape[0]))
    for i, x1 in enumerate(X1):
        for j, x2 in enumerate(X2):           
            x1 = x1.flatten()
            x2 = x2.flatten()
            gram_matrix[i, j] = Peptide_kernel(x1[2:11],x2[2:11]) * Supertype_kernel(x1[0:2],x2[0:2])
    sasa.append(gram_matrix)
    
    return gram_matrix


def Dirac_Classifier(X1,X2,Y):

    parameters = {'C':[0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000, 10000 ]}
    svc = svm.SVC(kernel="precomputed")
    clf = GridSearchCV(estimator=svc, param_grid=parameters, cv=11, n_jobs=-1)
    model = clf.fit( first_kernel(X1,X2), Y )
    
    return [model,clf]

def Uniform_Classifier(X1,X2,Y):
    
    parameters = {'C':[0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000, 10000 ]}
    svc = svm.SVC(kernel="precomputed")
    clf = GridSearchCV(estimator=svc, param_grid=parameters, cv=11, n_jobs=-1)
    model = clf.fit( second_kernel(X1,X2), Y )
    
    return [model,clf]
    
def Multitask_Classifier(X1,X2,Y):
    
    parameters = {'C':[0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000, 10000 ]}
    svc = svm.SVC(kernel="precomputed")
    clf = GridSearchCV(estimator=svc, param_grid=parameters, cv=11, n_jobs=-1)
    model = clf.fit( third_kernel(X1,X2), Y )
    
    return [model,clf]


def Supertype_Classifier(X1,X2,Y):
    
    parameters = {'C':[0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000, 10000 ]}
    svc = svm.SVC(kernel="precomputed")
    clf = GridSearchCV(estimator=svc, param_grid=parameters, cv=11, n_jobs=-1)
    model = clf.fit( fourth_kernel(X1,X2), Y )
    
    return [model,clf]



train_df = pd.read_csv('BindingData.csv')
train_data = train_df.iloc[:,2:4].as_matrix()
train_labels = train_df.iloc[:,4].as_matrix()


e = train_data[0,0]
k = 0
for i in range(len(train_data)):
    if train_data[i,0] == e : 
        train_data[i,0] = k
    else : 
        e = train_data[i,0]
        k+=1
        train_data[i,0] = k
        
        
Alpha = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R'
         ,'S','T','U','V','W','X','Y','Z']


for i in range(len(train_data)):
    el = train_data[i,1]
    aminos = []
    for k in range(len(el)):
        aminos.append(Alpha.index(train_data[i,1][k]))
    train_data[i,1] = np.array(aminos)

data = []
for i in range(len(train_data)):
    new = []
    new.append(train_data[i,0])
    for k in range(9):
        new.append(train_data[i,1][k])
    data.append(new)


data_without_supertype = data



data_without_supertype = np.array(data_without_supertype)
train_labels = np.array(train_labels)

# shuffle and split training and test sets
X_train, X_test, y_train, y_test = train_test_split(data_without_supertype, train_labels, test_size=.5,
                                                    random_state=0)

R = Multitask_Classifier(X_train,X_train,y_train)


p = R[0].predict( third_kernel(X_test,X_train) )
print(R[1].best_score_ )
print(R[1].best_estimator_.C )



# Compute ROC curve and ROC area for Multitask_Classifier
fpr = dict()
tpr = dict()
roc_auc = dict()

fpr, tpr, _ = roc_curve(y_test, p)
roc_auc = auc(fpr, tpr)

plt.figure()
lw = 2
plt.plot(fpr, tpr, color='darkorange',
         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic example')
plt.legend(loc="lower right")
plt.show()







''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''training including the supertypes'''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


supertype_df = pd.read_csv('supertype.csv', sep=',')
supertype_data = supertype_df.iloc[:,2]


supertype = []
for i in range(len(supertype_data)):

    supertype.append(supertype_data[i].split(', '))


train_df = pd.read_csv('BindingData.csv')
train_data = train_df.iloc[:,2]

alleles = []
for i in range(len(train_data)):

    alleles.append(train_data[i])
    
for i in range(len(alleles)):   
     alleles[i]=alleles[i][4:len(alleles[i])]
     alleles[i] = alleles[i].replace(":", "")



data_with_supertype = data

for e in range(len(alleles)):
    Found = False
    i=0
    while Found == False and i<9:
            ind = supertype[i].index(alleles[e]) if alleles[e] in supertype[i] else -1           
            if ind == -1 : i+=1
            else : 
                Found = True 
                Type = i
    
    if Found == True :
        data_with_supertype[e].insert(0, Type)
    else : data_with_supertype[e].insert(0,-1)
    
    


data_with_supertype =np.array(data_with_supertype)

# shuffle and split training and test sets
X_train, X_test, y_train, y_test = train_test_split(data_with_supertype, train_labels, test_size=.5,
                                                    random_state=0)


R = Supertype_Classifier(X_train,X_train,y_train)


p = R[0].predict( fourth_kernel(X_test,X_train) )
print(R[1].best_score_ )
print(R[1].best_estimator_.C )



# Compute ROC curve and ROC area for supertype_Classifier
fpr = dict()
tpr = dict()
roc_auc = dict()

fpr, tpr, _ = roc_curve(y_test, p)
roc_auc = auc(fpr, tpr)

plt.figure()
lw = 2
plt.plot(fpr, tpr, color='darkorange',
         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic example')
plt.legend(loc="lower right")
plt.show()









